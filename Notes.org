* Haskell compiler components
** ghc - Compile to native code
** ghci - Interactive scripting
** runghc - Run Programs as script
* ghci operation
** loading files into ghci
:load file.hs
** commands starts with :
** :quit
** :set +t to refer to operation as variable it
** :unset +t
** :module + Data.Ratio to add module, - to remove it
** :m +Data.Int for short
** :type var to show the variable name
** also have constants like pi
** keyword let to define our own values, can also reassign 
   let e = exp 1
** assignment in script is diffrent, cannot reassign
x = 10 
x = 11 this will be illegal
** functions don't need parenthesis, parens required to control the order of execution.
** show what variables are there
:show bindings
** Lists
*** Simple list 
let l = [1,2,3]
*** Enumerated list 
let el= [1..10]
*** next item in sequence
succ 7
*** previous item in sequence
pred 8
*** Adding lists using ++
let bigger = [2,3,4] ++ [5..10]
*** Only same type of items in the list
*** Add item to the beginning :
let onemore = 2 : [3,4,5]
*** get first  item of the list
head
*** get rest of the list
tail
*** get n elements of list
take n list
*** get all but first n
drop n list
** String
*** goes into double quotes.
let string = "This is a big string."
*** character goes into single quotes.
let c = 'c'
*** this will be illegal
let twochar='ac'
*** print a string
putStrLn "Printing a string\n"
* Type System
** Everything has a type
** Strong, Static, and inferred
*** Char - Unicode
*** Bool
*** Int - Fixed Width, Can OverFlow
*** Integer - Unbounded, Expensive, overFlow Handled
*** Double
*** find type of object
:type val
*** functions have type signature
* Indentations are important
* Evaluation
** lazily, not evaluated until needed,short circuit
** unevaluated/deferred expression is called thunk, haskell keeps track
** haskell functions can be polymorphic, types can be parameterised 
:type last
last :: [a] -> a
last takes any list of type 'a' and return element from it.
** type variable name are  kept short 'a', 'b' etc
** if one data type is encapulated within other, it needs to be initialized explictily.
data Authors = Authors Maybe Stirng

Data Book = Book Int String Authors
then this cannot be done
book = Book 23 "Hello Title" "I am the Author"
it needs to be
book = Book 23 "Hello Title" (Authors "I am him")
But if it is defined using type synonym
type Authors = String
then 
book = Book 222 "My Title" "My Author"
is legal
* Recursive Types
** Maybe Type can be used to define missing values
data Tree a = Tree(Maybe(a,Tree a,Tree a)) deriving (Show)
** Recursive types are defined in term of themselves
** However often it is easier to name components explicitly
data Tree a = Node a (Tree a) (Tree a)
            | Empty
            deriving (Show)
** Resoning becomes easier in comparision to when everyting is defined interms of itself

** let and where are sed to define 
lend amount balance = let reserve = 100
                          newBalance = amount - reserve
                      in  if balance < reserve
                          then Noting
                          else Just newbalance

*** let follows this
let <bindings>
in <expressiona>
*** binding defined are accessible after in.
*** let and in keywords should align
*** can be nested.
